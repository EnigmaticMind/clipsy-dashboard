// CSV service - generates and parses CSV files for Etsy listings
// Ported from backend Go code

import { ListingsResponse } from './etsyApi'
import { findHeaderRowIndex, decodeHTMLEntities } from '../utils/dataParsing'
import { LISTING_HEADER_ROW, LISTING_COLUMN_COUNT } from './googleSheets/constants'
import { APP_VERSION } from '../constants/version'

// Convert listings to CSV format
// New user-friendly structure: Listing info on every row, Variation column, logical grouping
export function convertListingsToCSV(listings: ListingsResponse): string {
  const rows: string[][] = []
  
  // Metadata rows (using column count from constants)
  const emptyRow = Array(LISTING_COLUMN_COUNT).fill('')
  
  // Version info row
  rows.push([
    `CLIPSY VERSION: v${APP_VERSION} - Generated by Clipsy Dashboard Extension`,
    ...emptyRow.slice(1)
  ])
  
  rows.push([
    'INFO: This CSV contains your Etsy listings. For listings with variations, the listing information appears on its own row, followed by separate rows for each variation. Listing-level fields (Title, Description, Status, Tags, Materials, Shipping Profile ID, Processing Time) are only on the listing row. Variation rows contain only variation-specific data.',
    ...emptyRow.slice(1)
  ])
  
  rows.push([
    'IMPORTANT: When uploading edits, keep Listing ID, Product ID, Property IDs intact. They identify which items to update.',
    ...emptyRow.slice(1)
  ])
  
  rows.push([
    'DELETE BEHAVIOR: SKU=\'DELETE\' deletes the entire listing/product. Variation SKU=\'DELETE\' deletes only that specific variation.',
    ...emptyRow.slice(1)
  ])
  
  rows.push([
    'UPLOAD BEHAVIOR: New records (no Listing ID) = Create new listing. Existing records (has Listing ID) = Update listing.',
    ...emptyRow.slice(1)
  ])
  
  // Empty row
  rows.push(emptyRow)
  
  // Header row - New user-friendly structure (imported from constants)
  rows.push([...LISTING_HEADER_ROW])
  
  // Process each listing
  for (const listing of listings.results) {
    if (listing.has_variations && listing.inventory.products.length > 0) {
      // First, generate a listing-only row (no variation data)
      const listingRow: string[] = [
        listing.listing_id.toString(),
        decodeHTMLEntities(listing.title),
        decodeHTMLEntities(listing.description),
        listing.state,
        listing.tags.join(','),
        '',  // No variation display on listing row
        '', '', '', '',  // No property names/options on listing row
        '',  // Price (empty - variations handle this)
        listing.price.currency_code,  // Currency code
        '',  // Quantity (empty - variations handle this)
        '',  // SKU (empty - variations handle this)
        '', '', '',  // No variation price/quantity/SKU on listing row
        listing.materials?.join(', ') || '',
        listing.shipping_profile_id?.toString() || '',
        listing.processing_min?.toString() || '',
        listing.processing_max?.toString() || '',
        '',  // No product_id on listing row
        '', '', '', '',  // No property IDs on listing row
      ]
      rows.push(listingRow)
      
      // Then, generate separate rows for each variation
      for (const product of listing.inventory.products) {
        if (product.is_deleted) continue
        
        // Find active offering
        const activeOffering = product.offerings.find(o => !o.is_deleted)
        if (!activeOffering) continue
        
        // Get property values
        const prop1 = product.property_values[0]
        const prop2 = product.property_values[1]
        
        // Build variation display string
        let variationDisplay = 'N/A'
        if (prop1 && prop1.values.length > 0) {
          variationDisplay = prop1.values.join(', ')
          if (prop2 && prop2.values.length > 0) {
            variationDisplay += ' / ' + prop2.values.join(', ')
          }
        } else if (prop2 && prop2.values.length > 0) {
          variationDisplay = prop2.values.join(', ')
        }
        
        // Determine price, quantity, SKU locations
        const hasPriceOnProperty = listing.inventory.price_on_property.length > 0
        const hasQuantityOnProperty = listing.inventory.quantity_on_property.length > 0
        const hasSKUOnProperty = listing.inventory.sku_on_property.length > 0
        
        // Variation-specific price/quantity/SKU
        let variationPrice = ''
        let variationQuantity = ''
        let variationSKU = ''
        let listingPrice = ''
        let listingQuantity = ''
        let listingSKU = ''
        
        if (hasPriceOnProperty) {
          const priceVal = activeOffering.price.amount / activeOffering.price.divisor
          variationPrice = priceVal.toFixed(2)
        } else {
          const priceVal = activeOffering.price.amount / activeOffering.price.divisor
          listingPrice = priceVal.toFixed(2)
        }
        
        if (hasQuantityOnProperty) {
          variationQuantity = activeOffering.quantity.toString()
        } else {
          listingQuantity = activeOffering.quantity.toString()
        }
        
        if (hasSKUOnProperty) {
          variationSKU = product.sku
        } else {
          listingSKU = product.sku
        }
        
        const variationRow: string[] = [
          listing.listing_id.toString(),  // Listing ID (for reference)
          '',  // No title on variation row
          '',  // No description on variation row
          '',  // No status on variation row
          '',  // No tags on variation row
          variationDisplay,
          prop1 ? prop1.property_name : '',
          prop1 ? prop1.values.join(', ') : '',
          prop2 ? prop2.property_name : '',
          prop2 ? prop2.values.join(', ') : '',
          listingPrice,  // Price (if not on property)
          listing.price.currency_code,  // Currency
          listingQuantity,  // Quantity (if not on property)
          listingSKU,  // SKU (if not on property)
          variationPrice,  // Variation Price (if price on property)
          variationQuantity,  // Variation Quantity (if quantity on property)
          variationSKU,  // Variation SKU (if SKU on property)
          '',  // No materials on variation row
          '',  // No shipping profile ID on variation row
          '',  // No processing min on variation row
          '',  // No processing max on variation row
          product.product_id.toString(),
          prop1 ? prop1.property_id.toString() : '',
          prop1 ? prop1.value_ids.join(',') : '',
          prop2 ? prop2.property_id.toString() : '',
          prop2 ? prop2.value_ids.join(',') : '',
        ]
        
        rows.push(variationRow)
      }
    } else {
      // No variations - single row (unchanged)
      let productID = ''
      let sku = ''
      let quantity = ''
      let price = ''
      let currencyCode = ''
      
      // Find first non-deleted product
      const product = listing.inventory.products.find(p => !p.is_deleted)
      if (product) {
        productID = product.product_id.toString()
        sku = product.sku
        const offering = product.offerings.find(o => !o.is_deleted)
        if (offering) {
          quantity = offering.quantity.toString()
          const priceVal = offering.price.amount / offering.price.divisor
          price = priceVal.toFixed(2)
          currencyCode = offering.price.currency_code
        }
      }
      
      // If no product, use listing-level data
      if (!productID) {
        if (listing.inventory.sku_on_property.length === 0 && listing.inventory.products.length > 0) {
          sku = listing.inventory.products[0].sku
        }
        quantity = listing.quantity.toString()
        const priceVal = listing.price.amount / listing.price.divisor
        price = priceVal.toFixed(2)
        currencyCode = listing.price.currency_code
      }
      
          rows.push([
            listing.listing_id.toString(),
            decodeHTMLEntities(listing.title),
            decodeHTMLEntities(listing.description),
            listing.state,
            listing.tags.join(','),
            'N/A',  // No variation (single row, so all data is present)
        '', '', '', '',  // No Property Names/Options
        price,
        currencyCode,
        quantity,
        sku,
        '', '', '',  // No variation price/quantity/SKU
        listing.materials?.join(', ') || '',  // Materials
        listing.shipping_profile_id?.toString() || '',  // Shipping Profile ID
        listing.processing_min?.toString() || '',  // Processing Min
        listing.processing_max?.toString() || '',  // Processing Max
        productID,
        '', '', '', '',  // No property IDs
      ])
    }
  }
  
  // Convert to CSV string (Excel-friendly with CRLF)
  return rows.map(row => {
    // Escape fields that contain commas, quotes, or newlines
    return row.map(field => {
      if (field.includes(',') || field.includes('"') || field.includes('\n')) {
        return `"${field.replace(/"/g, '""')}"`
      }
      return field
    }).join(',')
  }).join('\r\n')
}

// Download CSV as file
export function downloadCSV(csvContent: string, filename?: string): void {
  // Default filename includes version
  const defaultFilename = `clipsy-listings-v${APP_VERSION}.csv`
  const finalFilename = filename || defaultFilename
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  const link = document.createElement('a')
  const url = URL.createObjectURL(blob)
  
  link.setAttribute('href', url)
  link.setAttribute('download', finalFilename)
  link.style.visibility = 'hidden'
  
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  
  URL.revokeObjectURL(url)
}

// Count rows in CSV file quickly (without full parsing)
// Returns approximate data row count (excluding header)
export async function countCSVRows(file: File): Promise<number> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = async (e) => {
      const text = e.target?.result as string
      if (!text) {
        resolve(0)
        return
      }
      
      // Count lines (accounting for CRLF and LF)
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== '')
      
      if (lines.length === 0) {
        resolve(0)
        return
      }
      
      // Find header row index
      // Convert lines to 2D array for findHeaderRowIndex
      const rows = lines.map(line => line.split(',').map(cell => cell.trim().replace(/"/g, '')))
      let headerRowIndex = findHeaderRowIndex(rows, ['listing id'], 10)
      
      if (headerRowIndex === -1) {
        // No header found, assume first row is header
        headerRowIndex = 0
      }
      
      // Count data rows (excluding header and any info rows before it)
      // This is an approximation - actual count might vary due to variations
      // but it's close enough for a limit check
      const dataRowCount = lines.length - headerRowIndex - 1
      const actualCount = Math.max(0, dataRowCount)
      
      // Apply row count override if set (for testing/debugging)
      const { overrideRowCount } = await import('../utils/listingLimit')
      resolve(overrideRowCount(actualCount))
    }
    reader.onerror = () => reject(new Error('Failed to read CSV file'))
    reader.readAsText(file)
  })
}
